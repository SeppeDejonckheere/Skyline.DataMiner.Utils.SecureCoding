using System;
using System.Collections.Generic;

namespace SecureCoding.SecureSerialization
{
    /// <summary>
    /// Provides functionality to manage and verify known exploitable types.
    /// </summary>
    public static class KnownExploitableTypes
    {
        private static readonly List<string> knownExploitableTypes = new List<string>
        {
            // List based on the gadgets available in ysoserial.net
            "System.Workflow.ComponentModel.Serialization.ActivitySurrogateDisableTypeCheck",
            "System.Workflow.ComponentModel.Serialization.ActivitySurrogateSelector",
            "System.Windows.Forms.AxHostState",
            "System.Security.Claims.ClaimsIdentity",
            "System.Security.ClaimsClaimsPrincipal",
            "System.Data.DataSet",
            "System.Security.Principal.GenericPrincipal",
            "System.Windows.Data.ObjectDataProvider",
            "System.Runtime.Remoting.ObjRef",
            "System.Management.Automation.PSObject",
            "System.Resources.ResourceSet",
            "System.Web.Security.RolePrincipal",
            "System.IdentityModel.Tokens.SessionSecurityToken",
            "System.Web.UI.MobileControls.SessionViewState+SessionViewStateHistoryItem",
            "Microsoft.VisualStudio.Text.Formatting.TextFormattingRunProperties",
            "System.Drawing.Design.ToolboxItemContainer",
            "Microsoft.IdentityModel.Claims.WindowsClaimsIdentity",
            "System.Security.Principal.WindowsIdentity",
            "System.Security.Principal.WindowsPrincipal",
        };

        /// <summary>
        /// Verifies whether the given type is a known exploitable type.
        /// </summary>
        /// <param name="type">Type to verify.</param>
        /// <returns><see langword="true"/> if the type is found in the list of known exploitable types; otherwise, <see langword="false"/>.</returns>
        private static bool Contains(this Type type)
        {
            return knownExploitableTypes.Exists(t => type.FullName.Contains(t));
        }

        /// <summary>
        /// Indicates whether the specified <see cref="Type"/> object is considered a known exploitable type.
        /// </summary>
        /// <param name="type">The <see cref="Type"/> object to be checked for exploitability.</param>
        /// <returns><see langword="true"/> if the type is found in the list of known exploitable types; otherwise, <see langword="false"/>.</returns>
        /// <exception cref="ArgumentNullException">Thrown when the provided <paramref name="type"/> parameter is null.</exception>
        public static bool IsKnownExploitableType(this Type type)
        {
            if (type is null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            return Contains(type);
        }

        /// <summary>
        /// Determines whether the specified type name matches a known exploitable type.
        /// </summary>
        /// <param name="typeFullName">The fully qualified name of the type to check.</param>
        /// <returns><see langword="true"/> if the specified type name matches any known exploitable type;  otherwise, <see langword="false"/>.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="typeFullName"/> is <see langword="null"/>.</exception>
        /// <exception cref="ArgumentException"><paramref name="typeFullName"/> is empty or consists only of whitespace.</exception>
        /// <remarks>A case-insensitive comparison of the type name is performed.</remarks>
        public static bool IsKnownExploitableType(string typeFullName)
        {
            if( typeFullName is null)
            {
                throw new ArgumentNullException(nameof(typeFullName));
            }

            if (string.IsNullOrWhiteSpace(typeFullName))
            {
                throw new ArgumentException(nameof(typeFullName));
            }

            return knownExploitableTypes.Exists(t => typeFullName.ToLowerInvariant().Contains(t.ToLowerInvariant()));
        }

        /// <summary>
        /// Adds a new exploitable type to the list of known exploitable types, if it's not already present.
        /// </summary>
        /// <param name="type">The <see cref="Type"/> object representing the exploitable type to be added.</param>
        /// <returns><see langword="true"/> if the type was added successfully; otherwise, <see langword="false"/>.</returns>
        /// <exception cref="ArgumentNullException">Thrown when the provided <paramref name="type"/> parameter is null.</exception>
        public static bool AddExploitableType(Type type)
        {
            if (type is null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.IsKnownExploitableType())
            {
                return false;
            }

            knownExploitableTypes.Add(type.FullName);

            return true;
        }
    }
}
